# SONATE Canonicalization Specification v1.0

**Status:** Draft | **Implementation:** `@sonate/core/canonicalize.ts` & `packages/core/python/canonicalize.py`

To ensure that Trust Receipts are immutable, verifiable, and legally resilient, we must ensure that the input data (the Transcript) is converted into a **Deterministic Canonical Blob** before hashing and signing. This guarantees that the same logical conversation always produces the exact same hash, regardless of the machine, time, or language used to process it.

---

## 1. Design Goals

1.  **Deterministic**: Same logical transcript → identical canonical blob (bytes) → identical SHA-256 hash.
2.  **Privacy-Aware**: PII redaction occurs *before* canonicalization.
3.  **Canonical Ordering**: All JSON keys sorted lexicographically; array order preserved.
4.  **Stable Tokenization**: Normalize Unicode (NFC), line endings (LF), whitespace, and smart quotes.
5.  **Verifiable**: The receipt contains the SHA-256 of the canonical blob and a digital signature.
6.  **Cross-Language Parity**: Node.js and Python implementations must produce bit-identical outputs.

---

## 2. Canonicalization Specification

### 2.1 Input Data Selection
*   **Source**: Server-side transcript object used for resonance calculation.
*   **Included Fields**:
    *   `session_id` (string)
    *   `created_ms` (integer, UTC epoch)
    *   `model`: `{ name, revision }`
    *   `derived`: Key-value pairs of signal data (e.g., embedding seeds).
    *   `turns`: Array of turn objects.
*   **Excluded Fields**: Ephemeral system fields (PIDs, memory pointers, temp flags).

### 2.2 PII Redaction Policy
*   **Mode**: `replace-hash` (Recommended for production).
*   **Detector**: Regex + NER.
*   **Replacement**: `PII:TYPE:sha256(span)[:8]`.
    *   *Example*: `john@example.com` → `PII:EMAIL:a3f92b1c`
    *   This preserves the *fact* that PII existed and allows equality checks (did they mention the same email?) without revealing the PII.

### 2.3 Text Normalization Rules
Applied to every content string:
1.  **Unicode**: Normalize to **NFC** form.
2.  **Line Endings**: Convert all `CRLF` or `CR` to `LF` (`\n`).
3.  **Control Characters**: Remove C0 control chars (0x00-0x1F) except `LF` (0x0A).
4.  **Quotes & Dashes**: Normalize smart quotes (`“”«»‘’`) to ASCII (`"'`) and dashes (`–—`) to hyphen (`-`).
5.  **Whitespace**: Collapse multiple spaces/tabs to a single space. Trim leading/trailing whitespace. Preserve single newlines.

### 2.4 Structural Canonicalization
1.  **Sorting**: All object keys must be sorted lexicographically (bytewise).
2.  **Arrays**: Order is preserved (chronological).
3.  **Nulls**: Null fields are omitted entirely.
4.  **Timestamps**: Integer milliseconds (no floating point).

### 2.5 Deterministic Serialization
*   **Format**: JSON.
*   **Encoding**: UTF-8.
*   **Separators**: `","` and `":"` (no spaces).
*   **Escaping**: Minimal escaping. Do not escape `/` or non-ASCII characters unless required by JSON spec (control chars).

---

## 3. Receipt Schema

The final **Trust Receipt** generated from the canonical blob:

```json
{
  "receipt_id": "SHA-256 hash of canonical bytes (hex)",
  "canonical_schema": "sonate-canonical-v1",
  "canonical_hash": "SHA-256 hash of canonical bytes (hex)",
  "signer_key_id": "kms:aws:us-east-1:123456789012:key/...",
  "signer_pub_fingerprint": "SHA-256 of public key (hex)",
  "signature": "Base64 encoded signature (Ed25519 or ECDSA P-256)",
  "policy_version": "v2025-12-20-p01",
  "transcript_summary": {
    "turns_count": 12,
    "duration_ms": 45000,
    "rm_version": "v1.2.0"
  }
}
```

---

## 4. Implementation Details

### TypeScript (`packages/core/src/canonicalize.ts`)
Uses `JSON.stringify` on a key-sorted object, with manual text normalization helper.

### Python (`packages/core/python/canonicalize.py`)
Uses `json.dumps(..., sort_keys=True, separators=(',', ':'), ensure_ascii=False)` and `unicodedata.normalize`.

---

## 5. Testing & Verification

*   **Round-Trip Tests**: Ensure `canonicalize(A) === canonicalize(A)` even with noise variations.
*   **Parity Tests**: `hash(TS_Canonical(A))` MUST EQUAL `hash(PY_Canonical(A))`.
*   **Signing Tests**: Verify signatures generated by the implementation using public keys.

